# UnsafePipelineComponent

`UnsafePipelineComponent` is the base class from which all unsafe or experimental pipeline components inherit.
It is designed for **rapid prototyping**, flexible extension, and optional asynchronous execution.
Despite the name “unsafe,” it is purposely lightweight and permissive, allowing user-level code to override behavior more freely than a fully validated pipeline component.d


## Features
### ✔️ Synchronous and Asynchronous Execution

Components can be executed in either:

* `exec_mode='sync'` → invokes `_run`
* `exec_mode='async'` → invokes `_a_run` (if provided) or falls back to `run`

Execution is done via `__call__`, making components directly callable:
```python
result = component(data, exec_mode='sync')
await component(data, exec_mode='async')
```
---

### ✔️ Automatic Caching

Both sync and async execution paths are wrapped with an LRU cache.

* Controlled via the constructor: `cache_size`
* Exposed via `.cache_info()` and `.cache_clear()`
* Caching is applied after logger decorators

---
### ✔️ Optional Logging Decorator
A `logger_decorator` can be injected to wrap synchronous and asynchronous function calls:
```python
logger_decorator(func) -> wrapped_func
```
If none is provided, a simple identity decorator is used.

---
### ✔️ Automatic ID Generation

Each component instance receives a unique UUID:
```python
self.id = uuid.uuid4().hex
```
Useful for debugging, tracking pipeline stages, or logging.

---
### ✔️ Optional Async Override Hook

Users may define:
```python
async def _a_run(self, *args, **kwargs)
```
If missing, an async wrapper is automatically created that dispatches to the synchronous `run`:

```python
async def _a_run(self, *args, **kwargs):
    return self.run(*args, **kwargs)
```
---

### ✔️ Easy Copying / Cloning

Each component can produce a new instance of itself with the same configuration:
```python
new_component = component.deepcopy()
```

## Usage
### Creating a Custom Component

To define a custom pipeline component, override `_run`:
```python
from pipel import UnsafePipelineComponent, PipelData

class AddOne(UnsafePipelineComponent):
    def _run(self, x: int) -> PipelData:
        return PipelData(args=(x + 1,))
```

Using the component:
```python
c = AddOne()
result = c(PipelData(args=(1,)))
```
---
### Asynchronous Execution (Optional)
You may optionally define an asynchronous version:
```python
class SlowAdder(UnsafePipelineComponent):
    
    async def _a_run(self, x: int) -> PipelData:
        await asyncio.sleep(0.1)
        return PipelData(args=(x + 5))
    
    def _run(self, x: int) -> PipelData:
        return PipelData(args=(x + 5))
```
Use it like:
```python
await c(PipelData(args=(3,)), exec_mode='async')
```

If `_a_run` is not defined, the default async wrapper will call `run`.

---
### Constructor Parameters
```python
UnsafePipelineComponent(
    *,
    logger=None,
    cache_size: int = 0,
    logger_decorator=None,
)
```
|Parameter|	Type|Default|Description|
|---------|-----|-------|-----------|
|`logger`   |	`Any` |	`None`|	Optional logger for user code.|
|`cache_size`|	`int`|	`0`|	LRU cache size; 0 disables caching.|
|`logger_decorator`|	`Callable`|	`None`|	Function wrapping execution for logging, metrics, tracing, etc.|

---
## Execution
### Call Signature
```python
component(data: PipelData, exec_mode: EXEC_MODE = "sync")
```
---
### Execution Modes
|Mode|	Behavior|
|----|----------|
|`"sync"`	|Calls the cached _run implementation|
|`"async"`|	Calls the cached _a_run implementation (or fallback async wrapper)|

Invalid mode triggers a `ValueError`.
---
### Caching Interface
`cache_info()`

Returns the internal LRU cache statistics of either the sync or async executor.
```python
component.cache_info(exec_mode="sync")
```
`cache_clear()`

Clears the LRU cache for the given execution mode.
```python
component.cache_clear(exec_mode="async")
```
---
### Copying Components

`deepcopy()` returns a new instance of the same class, preserving:

* `logger`
* `logger_decorator`
* `cache_size`

Example:
```python
clone = component.deepcopy()
```
---
### String Representation

Readable representation useful for debugging:
```bash
<YourClassName>(id=..., logger=..., cache_size=...)
```

## Abstract Methods
`_run(self, *args, **kwargs) -> PipelData`

Must be implemented by subclasses.
Defines the synchronous execution logic of the component.

## Internals Overview

For advanced usage:

* `__run` and `__a_run` hold cached execution callables
* `_a_run` may be user-defined or autogenerated
* Decorators wrap before caching
* Execution is always invoked through `__call__`

## When should I use UnsafePipelineComponent?

Use this class when you want:

* fast iteration and experimentation
* optional async behavior
* caching & logging hooks
* inheritance-based composition
* simplicity over safety

For production-grade validation or strict type-safe pipelines, consider using safer alternatives.